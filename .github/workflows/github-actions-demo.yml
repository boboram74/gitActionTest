name: Send commit messages + changed files (push, robust)

on:
  push:
    branches: ['**']

jobs:
  send:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    env:
      APP_ENDPOINT: ${{ secrets.APP_ENDPOINT }}
      APP_TOKEN:    ${{ secrets.APP_TOKEN }}
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const commits = context.payload.commits || [];
            if (!commits.length) { core.info('no commits'); return; }

            const base = context.payload.before;
            const head = context.payload.after;

            const cmp = await github.rest.repos.compareCommits({
              owner, repo, base, head, per_page: 250
            });

            const MAX_BYTES = 200 * 1024;
            const MAX_CHARS = 20000;

            const getText = async (path, ref) => {
              if (!path) return null;
              try {
                const { data } = await github.rest.repos.getContent({ owner, repo, path, ref });
                if (!data || data.type !== 'file') return null;
                if (data.size > MAX_BYTES) return null;
                const buf = Buffer.from(data.content || '', data.encoding || 'base64');
                if (buf.includes(0)) return null;
                let text = buf.toString('utf8');
                if (text.length > MAX_CHARS) text = text.slice(0, MAX_CHARS) + '\n--TRUNCATED--';
                return text;
              } catch { return null; }
            };
            const files = await Promise.all((cmp.data.files || []).map(async f => {
              const status = f.status; // added | removed | modified | renamed
              const beforePath = status === 'added'   ? null : (f.previous_filename || f.filename);
              const afterPath  = status === 'removed' ? null : f.filename;
              const [beforeText, afterText] = await Promise.all([
                getText(beforePath, base),
                getText(afterPath,  head)
              ]);

              return {
                filename: f.filename,
                previous_filename: f.previous_filename ?? null,
                status:   f.status,
                additions: f.additions,
                deletions: f.deletions,
                changes:   f.changes,
                patch:     f.patch ?? null,
                beforeText,
                afterText
              };
            }));

            const body = {
              repo: { owner, name: repo },
              ref:  context.payload.ref,
              messages: commits.map(c => c.message),
              files
            };

            const res = await fetch(process.env.APP_ENDPOINT, {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${process.env.APP_TOKEN}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(body)
            });
            core.info(`POST -> ${res.status}`);
            if (!res.ok) core.setFailed(await res.text());
